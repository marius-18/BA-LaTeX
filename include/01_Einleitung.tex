%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%% Einleitung
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\glqq Bei der Analyse komplexer Netzwerke, wie beispielsweise sozialer Netzwerke, 
werden die zugrunde liegenden Graphen häufig mit zufälligen Graphen verglichen, 
um deren Struktur zu untersuchen.\grqq\footnote{frei übersetzt aus \cite{DBLP:conf/esa/CarstensH0PTW18} Abschntt 1}
Zum Erzeugen von zufälligen Graphen gibt es verschiedene Modelle wie beispielsweise der Erdos-Renyi-Graph \cite{erdos}
oder der Gilbert-Graph \cite{gilbert}.
\red{Diesen beiden Methoden ...?} 
Dabei haben aber die erstellten Graphen kaum eine Ähnlichkeit zu dem zu analysierenden Netzwerk.
Deshalb sind meist Zufallsgraphen gesucht, die zu einem gegebenen Graphen eine identische Gradsequenz
besitzen. Im Zufallsgraph soll also jeder Knoten den selben Grad haben wie im originalen Graph.
Ein Algorithmus, der diese Eigenschaft erfüllt ist beispielsweise Curveball \cite{curveball}.
Dabei wird ein Graph \glqq randomisiert, indem eine Sequenz an lokalen Modifikationen ausgeführt wird\grqq{}\footnote{frei übersetzt aus \cite{penschuck2020recent} Abschitt 6.4}
Diese lokalen Modifikationen werden als \ct{} bezeichnet. Bei einem \ct{} werden von zwei zufälligen 
Knoten die disjunkten Nachbarschaften durchgetauscht. Damit bleiben die Knotengrade unverändert.
Um den Graph zu randomisieren, werden einige von diesen \ct{en} hintereinander ausgeführt.
Um sicherzugehen, dass alle Knoten Teil eines \ct{es} gewesen sind, werden auf diese Weise
\glqq in Erwartung $\Theta(n\log(n))$  \ct{e} benötigt\grqq \footnote{frei übersetzt aus \cite{DBLP:conf/esa/CarstensH0PTW18} Abschitt 3.3}\red{. wohin mit dem punkt?}
Deswegen \red{wurde} eine Erweiterung namens \gc{} \cite{DBLP:conf/esa/CarstensH0PTW18} eingefügt. 
Für einen \gc{} Tausch werden 
\red{mehrere} \ct{e} nacheinander ausgeführt, sodass möglichst jeder Knoten Teil eines Tausches ist. 
\\
\\
Ziel dieser Bachelorarbeit ist es, \gc{} für bipartite Graphen anzupassen. Dazu werden gewisse 
Eigenschaften von bipartiten Graphen ausgenutzt, sodass Teile des originalen \gc{} Algorithmus
vereinfacht werden können. Ebenfalls ist es möglich einzelne \ct{e} parallel auszuführen.
Auf diese Weise soll eine deutlich geringere Laufzeit im Vergleich zu dem ursprünglichen \gc{}
Algorithmus erreicht werden.
Der neu entwickelte Algorithmus wird unter dem Namen \texttt{BipartiteGlobalCurveball} 
Teil vom Open-Source Projekt \nk{} werden.
\\
\\
Zu Beginn dieser Arbeit werden die wichtigsten Begriffe und mathematischen Grundlagen definitiert.
Im Anschluss werden verschiedenen Methoden, \gc{} umzusetzen,  besprochen und \red{ unter theorethischen
Aspekten verglichen.} 
Mit Hilfe von Benchmark Tests, wird schließlich die Methode ausgewählt, welche die geringste Laufzeit 
benötigt.
