%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%% Einleitung
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Bei der Analyse komplexer Netzwerke, wie beispielsweise soziale Netzwerke, 
werden die zugrundeliegenden Graphen häufig mit zufälligen Graphen verglichen, 
um deren Struktur zu untersuchen\cite{DBLP:conf/esa/CarstensH0PTW18}.
\\

Zum Erzeugen von zufälligen Graphen existieren diverse Modelle wie 
beispielsweise der Erd\H{o}s-R\'enyi-Graph \cite{erdos}
oder der Gilbert-Graph \cite{gilbert}.
Diese Graphen
weisen jedoch in der Regel kaum eine Ähnlichkeit zu dem zu analysierenden Netzwerk auf.
Deshalb verwendet man Zufallsgraphen, die zu einem gegebenen Graphen eine identische Gradsequenz
besitzen. Im Zufallsgraph soll also jeder Knoten denselben Grad haben wie im originalen Graph.
\\

Ein Algorithmus, welcher diese Eigenschaft erfüllt, ist beispielsweise \cb{} \cite{curveball}.
Hierbei wird ein Graph randomisiert, indem eine Sequenz an lokalen Modifikationen ausgeführt wird \cite{penschuck2020recent}.
Diese lokalen Modifikationen werden als \ct{} bezeichnet. Bei einem \ct{} werden von zwei zufälligen 
Knoten die disjunkten Nachbarschaften zufällig durchgetauscht, damit bleiben die Knotengrade unverändert.
Um den Graph zu randomisieren, werden einige dieser \ct{e} hintereinander auf jeweils zufälligen Knoten ausgeführt.
Um sicherzugehen, dass alle Knoten Teil eines \ct{es} waren, werden auf diese Weise
in Erwartung $\Theta(n\log(n))$  \ct{e} benötigt \cite{DBLP:conf/esa/CarstensH0PTW18}.
Um dies zu umgehen, wurde eine Erweiterung namens \gc{} \cite{DBLP:conf/esa/CarstensH0PTW18} eingeführt. 
Ein \gc{} Tausch ist ein \glqq Super-Schritt\grqq \cite{penschuck2020recent}, in dem mehrere \ct{e} auf jeweils
unterschiedlichen Knoten nacheinander ausgeführt werden, sodass möglichst jeder Knoten Teil eines solchen Tausches ist. 
Somit werden lediglich $\Theta(n)$ viele \ct{e} benötigt,
damit möglichst alle Knoten abgedeckt sind.
\\

Ziel dieser Bachelorarbeit ist die Anpassung von \gc{} an bipartite Graphen zur 
Reduzierung der Laufzeit. 
Zum einen werden die reduzierten Abhängigkeiten in
 bipartiten Graphen ausgenutzt, sodass Teile des originalen \gc{} Algorithmus
vereinfacht werden können. Zum anderen ist es möglich, einzelne \ct{e} parallel auszuführen.
Auf diese Weise soll ---wie bereits erwähnt--- eine deutlich geringere Laufzeit im Vergleich zu dem ursprünglichen \gc{}
Algorithmus erreicht werden.
Der neu entwickelte Algorithmus wird unter dem Namen \texttt{BipartiteGlobalCurveball} 
Teil des Open-Source Projekt \nk{} werden.
\\

Zu Beginn dieser Arbeit werden die wichtigsten Begriffe und mathematischen Grundlagen definiert.
Im Anschluss werden verschiedene Algorithmen zur Umsetzung von \gc{}  aufgezeigt und unter Einbeziehung 
theoretischer Aspekte miteinander verglichen.
Mit Hilfe von Benchmark-Tests wird schließlich die Methode ausgewählt, welche die geringste Laufzeit 
aufweist. Die neu entwickelte Variante \texttt{BipartiteGlobalCurveball} wird abschließend 
mit dem existierenden \cb{} verglichen.
