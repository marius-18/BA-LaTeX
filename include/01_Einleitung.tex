%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%% Einleitung
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\glqq Bei der Analyse komplexer Netzwerke, wie beispielsweise soziale Netzwerke, 
werden die zugrundeliegenden Graphen häufig mit zufälligen Graphen verglichen, 
um deren Struktur zu untersuchen.\grqq\footnote{frei übersetzt aus \cite{DBLP:conf/esa/CarstensH0PTW18} Abschnitt 1}
\\

Zum Erzeugen von zufälligen Graphen existieren diverse Modelle wie beispielsweise der Erdos-Renyi-Graph \cite{erdos}
oder der Gilbert-Graph \cite{gilbert}.
\red{Diesen beiden Methoden ...?} 
Dabei weisen jedoch die erstellten Graphen kaum eine Ähnlichkeit zu dem zu analysierenden Netzwerk auf.
Deshalb sind meist Zufallsgraphen gesucht, die zu einem gegebenen Graphen eine identische Gradsequenz
besitzen. Im Zufallsgraph soll also jeder Knoten denselben Grad haben wie im originalen Graph.
\\

Ein Algorithmus, welcher diese Eigenschaft erfüllt, ist beispielsweise Curveball \cite{curveball}.
Hierbei wird ein Graph \glqq randomisiert, indem eine Sequenz an lokalen Modifikationen ausgeführt wird\grqq\footnote{\label{ftn:survey}frei übersetzt aus \cite{penschuck2020recent} Abschnitt 6.4}.
Diese lokalen Modifikationen werden als \ct{} bezeichnet. Bei einem \ct{} werden von zwei zufälligen 
Knoten die disjunkten Nachbarschaften durchgetauscht. Damit bleiben die Knotengrade unverändert.
Um den Graph zu randomisieren, werden einige von diesen \ct{en} hintereinander auf jeweils zufälligen Knoten ausgeführt.
Um sicherzugehen, dass alle Knoten Teil eines \ct{es} waren, werden auf diese Weise
\glqq in Erwartung $\Theta(n\log(n))$  \ct{e} benötigt\grqq \footnote{frei übersetzt aus \cite{DBLP:conf/esa/CarstensH0PTW18} Abschnitt 3.3}.
Um dies zu umgehen, \red{wurde} eine Erweiterung namens \gc{} \cite{DBLP:conf/esa/CarstensH0PTW18} eingeführt. 
Ein \gc{} Tausch ist ein \glqq Super-Schritt\grqq \footref{ftn:survey}, in dem mehrere \ct{e} auf jeweils
unterschiedlichen Knoten nacheinander ausgeführt werden, sodass möglichst jeder Knoten Teil eines solchen Tausches ist. 
Somit werden lediglich $\Theta(n)$ viele \ct{e} benötigt, %um sicherzugehen, 
damit möglichst alle Knoten abgedeckt sind.
%Um so viele Knoten wie möglich durch \ct{e} abzudecken, ist somit nur ein einziger \gc{} Schritt notwendig.
%Somit ist nach nur einem \gc{} Schritt möglichst jeder Knoten Teil eines \ct{es} gewesen.
\\

Ziel dieser Bachelorarbeit ist die Anpassung von \gc{} an bipartite Graphen zur 
Reduzierung der Laufzeit. Zum einen werden gewisse 
Eigenschaften von bipartiten Graphen ausgenutzt, sodass Teile des originalen \gc{} Algorithmus
vereinfacht werden können. Zum anderen ist es möglich, einzelne \ct{e} parallel auszuführen.
Auf diese Weise soll --- wie bereits erwähnt --- eine deutlich geringere Laufzeit im Vergleich zu dem ursprünglichen \gc{}
Algorithmus erreicht werden.
Der neu entwickelte Algorithmus wird unter dem Namen \texttt{BipartiteGlobalCurveball} 
Teil vom Open-Source Projekt \nk{} werden.
\\
\\
\newpage
Zu Beginn dieser Arbeit werden die wichtigsten Begriffe und mathematischen Grundlagen definitiert.
Im Anschluss werden verschiedene Methoden, \gc{} umzusetzen,  aufgezeigt und \red{ unter Einbeziehung 
theoretischer Aspekte miteinander verglichen.} 
Mit Hilfe von Benchmark Tests wird schließlich die Methode ausgewählt, welche die geringste Laufzeit 
aufweist.
